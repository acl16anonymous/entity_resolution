#include <iostream>
#include <set>
#include <map>
#include <vector>
#include <sstream>
#include <fstream>
#include <math.h>
#include <stdlib.h>    
#include <time.h> 

#include "../util/io.h"
#include "../util/util.h"
#include "../util/clique.h"


using namespace std;

/*
 * Our refinement algorithm works as follows:
 * 1. For each vertex, determine the maximum clique with minimum distance. 
 *        Each clique contains at least one vertex and they cover all the vertices.
 *        Duplicate max-cliques are removed. All these cliques server as the candidates.
 * 2. Sort the vertex based on the number of occurrence in the max-cliques.
 *        If a vertex occurs only once, there is no conflict.
 *        Otherwise, there is a conflict and we need to determine which one it should belong
 * 3. Determine all the conflict vertexes, starting from the one with the minimum conflict.
 */


// global data structures
int N;           // number of entities/vertices in the graph
int** graph;     // two-dimensional array for quick graph edge deletion. N*(N+1) dimension with the last column for real length.
double* p_score;  // the weight for each pair of edge


double threshold=0.6;
map<string, Clique*> cands;



void addEdge(int id1, int id2)
{
	graph[id1][graph[id1][N]] = id2;
	graph[id1][N]++;

	graph[id2][graph[id2][N]] = id1;
	graph[id2][N]++;
}


/*
 * calculate the incremental score by adding a
 * new node to an existing clique.
 *
 */
double incremental(Clique* clique, int other)
{
	double gain=0;
	for(set<int>::iterator iter=clique->nodes.begin();iter != clique->nodes.end();iter++){
		int id1 = *iter;
		gain += 2*p_score[id1*N+other]-1;
	}
	return gain;
}


double remove(Clique* clique, int node)
{
	double gain = 0.5*(clique->nodes.size()-1);
	for(set<int>::iterator iter=clique->nodes.begin();iter != clique->nodes.end();iter++){
		int id1 = *iter;
		gain -= p_score[id1*N+node];
	}
	return gain;
}


/*
 * For each edge, find the best expansion
 * Purpose: avoid genearting exponential number of cliques
 */
Clique* expandEdge(int id1, int id2)
{
	Clique* clique = new Clique();
	clique->addNode(id1);
	clique->addNode(id2);
	
	while(true){
		// find the next neighbour with maximum gain
		double max_gain=-1;
		int next_node=0;
		for(int new_id=0;new_id < N;new_id++){
			if(clique->nodes.find(new_id) == clique->nodes.end()){
				double gain = incremental(clique, new_id);
				if(gain >= max_gain){
					next_node=new_id;
					max_gain = gain;
				}
			}
		}
		if(max_gain >= 0){
			clique->addNode(next_node);
		}else{
			break;
		}
	}

	return clique;
}


void generateMaxCliques()
{
	for(int id1=0;id1 < N;id1++){
		int len = graph[id1][N];
		for(int i=0;i < len;i++){
			int id2 = graph[id1][i];
			if(id1 < id2){
				Clique* clique = expandEdge(id1, id2);
				string key = clique->toString();
				if(cands.find(key) == cands.end()){
					cands[key] = clique;
				}
			}
		}
	}
}


void refine()
{
	cout<<endl<<"candidates:"<<endl;
	map<string,Clique*>::iterator iter;
	for(iter=cands.begin();iter != cands.end();iter++){
		cout<<iter->first<<endl;
	}
	
	// calculate the occurrance for each vertex
	map<int,int> node_count;
	for(iter=cands.begin();iter != cands.end();iter++){
		Clique* clique=iter->second;
		for(set<int>::iterator n_iter=clique->nodes.begin();n_iter != clique->nodes.end();n_iter++){
			node_count[*n_iter]++;
		}
	}

	// sort the vertex based on frequency
	map<int,vector<int> > buckets;
	for(map<int,int>::iterator n_iter=node_count.begin();n_iter != node_count.end();n_iter++){
		buckets[n_iter->second].push_back(n_iter->first);
	}


	for(map<int, vector<int> >::iterator b_iter=buckets.begin();b_iter != buckets.end();b_iter++){
		if(b_iter->first > 1){
			vector<int> nodes = b_iter->second;
			for(size_t i=0;i < nodes.size();i++){
				cout<<b_iter->first<<"\t"<<nodes[i]<<endl;
			}
		}
	}
}


/*
 * After random walk, we propose refinement steps to improve the accuracy.
 *
 */
int main(int argc, char** argv)
{
	// load the groundtruth dataset
	string dataset = "paper";
	vector<string> source = FileIO::readFileLines("data/"+dataset+"/source.txt");
	set<string> matches = FileIO::readMatch("data/"+dataset+"/match.txt");
	N = source.size();
	cout<<N<<endl;

	// construct the data structures
	p_score = new double[N*N];
	graph = new int*[N];
	for(int i=0;i < N;i++){
		graph[i] = new int[N+1];
		graph[i][N]=0;
	}
	p_score = new double[N*N];
	for(int i=0;i < N*N;i++){
		p_score[i]=0;
	}


	// load the graph generated by random walk
	ifstream c_fin((dataset+".clique").c_str());
	int id1,id2;
	double old_weight, weight;
	int edge=0;
	while(c_fin.good()){
		c_fin>>id1>>id2>>old_weight>>weight;
		if(id2 < id1 && weight > threshold){
			p_score[id1*N+id2]=weight;
			p_score[id2*N+id1]=weight;
			addEdge(id1, id2);
			edge++;

		}
		if(id1 > 100){
			break;
		}
	}
	cout<<"edge number: "<<edge<<endl;
	c_fin.close();

	// generate clique candidates
	generateMaxCliques();	


	// refine cliques
	refine();
	
	return 1;
}
